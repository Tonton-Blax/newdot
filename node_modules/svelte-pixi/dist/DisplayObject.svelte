<script>var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
import { createEventDispatcher, getContext, onMount, tick } from 'svelte';
import { shouldApplyProps, createPixiEventDispatcher } from './util';
export let accessible = undefined;
export let accessibleChildren = true;
export let accessibleHint = undefined;
export let accessiblePointerEvents = 'auto';
export let accessibleTitle = undefined;
export let accessibleType = undefined;
export let alpha = undefined;
export let angle = undefined;
export let buttonMode = undefined;
export let cacheAsBitmap = undefined;
export let cursor = undefined;
export let filterArea = undefined;
export let filters = undefined;
export let hitArea = undefined;
export let interactive = undefined;
export let mask = undefined;
export let name = undefined;
export let pivot = undefined;
export let position = undefined;
export let renderable = undefined;
export let rotation = undefined;
export let scale = undefined;
export let skew = undefined;
export let transform = undefined;
export let visible = undefined;
export let x = undefined;
export let y = undefined;
export let zIndex = undefined;
/**
 * Optionally provide the parent Container instance this DisplayObject should be added to.
 */
export let parent = getContext('pixi/container') ||
    getContext('pixi/stage');
/** @type {PIXI.DisplayObject} PIXI.DisplayObject instance to render */
export let instance;
const dispatch = createEventDispatcher();
const app = getContext('pixi/app');
onMount(() => {
    let childIndex = -1;
    // make sure child isn't already added to the parent
    try {
        // Container.getChildIndex throws an error if instance is not a child...
        childIndex = parent.getChildIndex(instance);
    }
    catch (e) { }
    if (parent && childIndex === -1) {
        parent.addChild(instance);
    }
    else {
        throw new Error('Unable to find container or stage');
    }
    return () => {
        parent === null || parent === void 0 ? void 0 : parent.removeChild(instance);
    };
});
$: shouldApplyProps(alpha) && (instance.alpha = alpha);
$: shouldApplyProps(accessible) && (instance.accessible = accessible);
$: shouldApplyProps(accessibleChildren) &&
    (instance.accessibleChildren = accessibleChildren);
$: shouldApplyProps(accessibleHint) &&
    (instance.accessibleHint = accessibleHint);
$: shouldApplyProps(accessiblePointerEvents) &&
    (instance.accessiblePointerEvents = accessiblePointerEvents);
$: shouldApplyProps(accessibleTitle) &&
    (instance.accessibleTitle = accessibleTitle);
$: shouldApplyProps(accessibleType) &&
    (instance.accessibleType = accessibleType);
$: shouldApplyProps(angle) && (instance.angle = angle);
$: shouldApplyProps(buttonMode) && (instance.buttonMode = buttonMode);
$: shouldApplyProps(cacheAsBitmap) && (instance.cacheAsBitmap = cacheAsBitmap);
$: shouldApplyProps(cursor) && (instance.cursor = cursor);
$: shouldApplyProps(filterArea) && (instance.filterArea = filterArea);
$: shouldApplyProps(filters) && (instance.filters = filters);
$: shouldApplyProps(hitArea) && (instance.hitArea = hitArea);
$: shouldApplyProps(interactive) && (instance.interactive = interactive);
$: shouldApplyProps(mask) && (instance.mask = mask);
$: shouldApplyProps(name) && (instance.name = name);
$: shouldApplyProps(pivot) && (instance.pivot = pivot);
$: shouldApplyProps(position) && (instance.position = position);
$: shouldApplyProps(renderable) && (instance.renderable = renderable);
$: shouldApplyProps(rotation) && (instance.rotation = rotation);
$: shouldApplyProps(scale) && (instance.scale = scale);
$: shouldApplyProps(skew) && (instance.skew = skew);
$: shouldApplyProps(transform) && (instance.transform = transform);
$: shouldApplyProps(visible) && (instance.visible = visible);
$: shouldApplyProps(x) && (instance.x = x);
$: shouldApplyProps(y) && (instance.y = y);
$: shouldApplyProps(zIndex) && (instance.zIndex = zIndex);
onMount(() => {
    function updateProps() {
        return __awaiter(this, void 0, void 0, function* () {
            yield tick();
            alpha = instance.alpha;
            accessible = instance.accessible;
            accessibleChildren = instance.accessibleChildren;
            accessibleHint = instance.accessibleHint;
            accessiblePointerEvents = instance.accessiblePointerEvents;
            accessibleTitle = instance.accessibleTitle;
            accessibleType = instance.accessibleType;
            angle = instance.angle;
            buttonMode = instance.buttonMode;
            cacheAsBitmap = instance.cacheAsBitmap;
            cursor = instance.cursor;
            filterArea = instance.filterArea;
            filters = instance.filters;
            hitArea = instance.hitArea;
            interactive = instance.interactive;
            mask = instance.mask;
            name = instance.name;
            pivot = instance.pivot;
            position = instance.position;
            renderable = instance.renderable;
            rotation = instance.rotation;
            scale = instance.scale;
            skew = instance.skew;
            transform = instance.transform;
            visible = instance.visible;
            x = instance.x;
            y = instance.y;
            zIndex = instance.zIndex;
        });
    }
    app.ticker.add(updateProps);
    const dispatchers = [
        createPixiEventDispatcher(instance, dispatch, 'click'),
        createPixiEventDispatcher(instance, dispatch, 'mousedown'),
        createPixiEventDispatcher(instance, dispatch, 'mousemove'),
        createPixiEventDispatcher(instance, dispatch, 'mouseout'),
        createPixiEventDispatcher(instance, dispatch, 'mouseover'),
        createPixiEventDispatcher(instance, dispatch, 'mouseup'),
        createPixiEventDispatcher(instance, dispatch, 'mouseupoutside'),
        createPixiEventDispatcher(instance, dispatch, 'mouseupoutside'),
        createPixiEventDispatcher(instance, dispatch, 'pointercancel'),
        createPixiEventDispatcher(instance, dispatch, 'pointerdown'),
        createPixiEventDispatcher(instance, dispatch, 'pointermove'),
        createPixiEventDispatcher(instance, dispatch, 'pointerout'),
        createPixiEventDispatcher(instance, dispatch, 'pointerover'),
        createPixiEventDispatcher(instance, dispatch, 'pointertap'),
        createPixiEventDispatcher(instance, dispatch, 'pointerup'),
        createPixiEventDispatcher(instance, dispatch, 'pointerupoutside'),
        createPixiEventDispatcher(instance, dispatch, 'removedFrom'),
        createPixiEventDispatcher(instance, dispatch, 'rightclick'),
        createPixiEventDispatcher(instance, dispatch, 'rightdown'),
        createPixiEventDispatcher(instance, dispatch, 'rightup'),
        createPixiEventDispatcher(instance, dispatch, 'rightupoutside'),
        createPixiEventDispatcher(instance, dispatch, 'tap'),
        createPixiEventDispatcher(instance, dispatch, 'touchcancel'),
        createPixiEventDispatcher(instance, dispatch, 'touchend'),
        createPixiEventDispatcher(instance, dispatch, 'touchendoutside'),
        createPixiEventDispatcher(instance, dispatch, 'touchmove'),
        createPixiEventDispatcher(instance, dispatch, 'touchstart'),
        createPixiEventDispatcher(instance, dispatch, 'added'),
        createPixiEventDispatcher(instance, dispatch, 'removed'),
    ];
    return () => {
        dispatchers.forEach((remove) => remove());
        app.ticker.remove(updateProps);
    };
});
</script>

<svelte:options immutable />
<slot />
